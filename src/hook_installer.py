#!/usr/bin/env python3
"""
Git Hook Installer for Mistral Code Reviewer
Automatically installs pre-commit hooks for code review
"""

import os
import sys
import shutil
import subprocess
from pathlib import Path
from typing import Optional, List

class GitHookInstaller:
    """Installer for Git hooks with Mistral code review"""
    
    def __init__(self, repo_path: str = "."):
        self.repo_path = Path(repo_path).resolve()
        self.git_dir = self.repo_path / ".git"
        self.hooks_dir = self.git_dir / "hooks"
        self.pre_commit_hook = self.hooks_dir / "pre-commit"
        
    def is_git_repo(self) -> bool:
        """Check if the directory is a Git repository"""
        return self.git_dir.exists() and self.git_dir.is_dir()
    
    def install_pre_commit_hook(self, force: bool = False) -> bool:
        """Install the pre-commit hook with Mistral code review"""
        try:
            if not self.is_git_repo():
                print("‚ùå Not a Git repository")
                return False
            
            # Create hooks directory if it doesn't exist
            self.hooks_dir.mkdir(exist_ok=True)
            
            # Check if hook already exists
            if self.pre_commit_hook.exists() and not force:
                print(f"‚ö†Ô∏è  Pre-commit hook already exists at {self.pre_commit_hook}")
                response = input("Do you want to overwrite it? (y/N): ")
                if response.lower() != 'y':
                    print("Installation cancelled")
                    return False
            
            # Create the pre-commit hook script
            hook_content = self._generate_pre_commit_hook()
            
            with open(self.pre_commit_hook, 'w') as f:
                f.write(hook_content)
            
            # Make the hook executable
            os.chmod(self.pre_commit_hook, 0o755)
            
            print(f"‚úÖ Pre-commit hook installed at {self.pre_commit_hook}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error installing pre-commit hook: {e}")
            return False
    
    def uninstall_pre_commit_hook(self) -> bool:
        """Remove the pre-commit hook"""
        try:
            if self.pre_commit_hook.exists():
                self.pre_commit_hook.unlink()
                print(f"‚úÖ Pre-commit hook removed from {self.pre_commit_hook}")
                return True
            else:
                print("‚ÑπÔ∏è  No pre-commit hook found to remove")
                return True
        except Exception as e:
            print(f"‚ùå Error removing pre-commit hook: {e}")
            return False
    
    def _generate_pre_commit_hook(self) -> str:
        """Generate the pre-commit hook script content"""
        # Get the path to the code reviewer script
        current_dir = Path(__file__).parent
        code_reviewer_path = current_dir / "code_reviewer.py"
        
        hook_script = f"""#!/bin/bash
# Pre-commit hook for Mistral Code Review
# Generated by SmartGitMergePT

set -e

echo "üîç Running Mistral Code Review..."

# Get the repository root
REPO_ROOT="$(git rev-parse --show-toplevel)"

# Run the code reviewer
python3 "{code_reviewer_path}" "$REPO_ROOT"

# Check the exit code
if [ $? -ne 0 ]; then
    echo "‚ùå Code review failed - commit blocked"
    exit 1
else
    echo "‚úÖ Code review passed - commit can proceed"
    exit 0
fi
"""
        return hook_script
    
    def test_hook(self) -> bool:
        """Test the installed pre-commit hook"""
        try:
            if not self.pre_commit_hook.exists():
                print("‚ùå Pre-commit hook not found")
                return False
            
            print("üß™ Testing pre-commit hook...")
            
            # Create a test file
            test_file = self.repo_path / "test_code_review.py"
            test_content = '''
def bad_function():
    password = "hardcoded_secret_123"  # Security issue
    x = 1 + 1  # Simple operation
    return x

# Missing docstring
def another_function():
    pass
'''
            
            with open(test_file, 'w') as f:
                f.write(test_content)
            
            # Stage the file
            subprocess.run(["git", "add", str(test_file)], cwd=self.repo_path, check=True)
            
            # Try to commit (this should trigger the hook)
            try:
                result = subprocess.run(
                    ["git", "commit", "-m", "Test commit for code review"],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    print("‚úÖ Hook test passed - commit succeeded")
                    # Clean up
                    subprocess.run(["git", "reset", "--soft", "HEAD~1"], cwd=self.repo_path, check=True)
                    subprocess.run(["git", "reset"], cwd=self.repo_path, check=True)
                    test_file.unlink()
                    return True
                else:
                    print("‚úÖ Hook test passed - commit blocked as expected")
                    print("Output:", result.stdout)
                    print("Errors:", result.stderr)
                    # Clean up
                    subprocess.run(["git", "reset"], cwd=self.repo_path, check=True)
                    test_file.unlink()
                    return True
                    
            except subprocess.TimeoutExpired:
                print("‚ö†Ô∏è  Hook test timed out")
                # Clean up
                subprocess.run(["git", "reset"], cwd=self.repo_path, check=True)
                test_file.unlink()
                return False
                
        except Exception as e:
            print(f"‚ùå Error testing hook: {e}")
            return False
    
    def list_installed_hooks(self) -> List[str]:
        """List all installed Git hooks"""
        hooks = []
        if self.hooks_dir.exists():
            for hook_file in self.hooks_dir.iterdir():
                if hook_file.is_file() and hook_file.name.endswith(('.sample', '')):
                    hooks.append(hook_file.name)
        return hooks
    
    def check_ollama_status(self) -> bool:
        """Check if Ollama is running and accessible"""
        try:
            import requests
            response = requests.get("http://localhost:11434/v1/tags", timeout=5)
            if response.status_code == 200:
                models = response.json().get("models", [])
                mistral_available = any("mistral" in model.get("name", "").lower() for model in models)
                if mistral_available:
                    print("‚úÖ Ollama is running and Mistral model is available")
                    return True
                else:
                    print("‚ö†Ô∏è  Ollama is running but Mistral model not found")
                    print("   Run: ollama pull mistral")
                    return False
            else:
                print("‚ùå Ollama is not responding")
                return False
        except ImportError:
            print("‚ùå requests library not available")
            return False
        except Exception as e:
            print(f"‚ùå Error checking Ollama status: {e}")
            return False

def main():
    """Main function for hook installer"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Install Git hooks for Mistral Code Review")
    parser.add_argument("--repo-path", default=".", help="Path to Git repository")
    parser.add_argument("--install", action="store_true", help="Install pre-commit hook")
    parser.add_argument("--uninstall", action="store_true", help="Remove pre-commit hook")
    parser.add_argument("--test", action="store_true", help="Test the installed hook")
    parser.add_argument("--force", action="store_true", help="Force overwrite existing hook")
    parser.add_argument("--check-ollama", action="store_true", help="Check Ollama status")
    parser.add_argument("--list-hooks", action="store_true", help="List installed hooks")
    
    args = parser.parse_args()
    
    installer = GitHookInstaller(args.repo_path)
    
    if args.check_ollama:
        installer.check_ollama_status()
        return
    
    if args.list_hooks:
        hooks = installer.list_installed_hooks()
        if hooks:
            print("Installed hooks:")
            for hook in hooks:
                print(f"  - {hook}")
        else:
            print("No hooks found")
        return
    
    if args.uninstall:
        installer.uninstall_pre_commit_hook()
        return
    
    if args.test:
        installer.test_hook()
        return
    
    if args.install:
        print("üöÄ Installing Mistral Code Review Pre-commit Hook")
        print("=" * 50)
        
        # Check Ollama status
        if not installer.check_ollama_status():
            print("\n‚ö†Ô∏è  Ollama not ready. Please:")
            print("   1. Install Ollama: curl -fsSL https://ollama.ai/install.sh | sh")
            print("   2. Start Ollama: ollama serve")
            print("   3. Pull Mistral: ollama pull mistral")
            print("\nContinue anyway? (y/N): ")
            response = input()
            if response.lower() != 'y':
                return
        
        # Install the hook
        if installer.install_pre_commit_hook(args.force):
            print("\n‚úÖ Installation completed successfully!")
            print("\nThe pre-commit hook will now run automatically before each commit.")
            print("It will review your code using Mistral AI and block commits with issues.")
            
            # Offer to test
            print("\nWould you like to test the hook now? (y/N): ")
            response = input()
            if response.lower() == 'y':
                installer.test_hook()
        else:
            print("‚ùå Installation failed")
            return 1
    
    if not any([args.install, args.uninstall, args.test, args.check_ollama, args.list_hooks]):
        parser.print_help()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
